//! # Distinct Powers
//!
//! Consider all integer combinations of aⁿ for 2 <= a <= 5 and 2 <= n <= 5:
//!
//! | a | a² | a³ | a⁴ | a⁵ |
//! |---|----|----|----|----|
//! | 2 | 4 | 8 | 16 | 32 |
//! | 3 | 9 | 27 | 81 | 243 |
//! | 4 | 16 | 64 | 256 | 1024 |
//! | 5 | 25 | 125 | 625 | 3125 |
//!
//! If they are then placed in numerical order, with any repeats removed, we get the following
//! sequence of 15 distinct terms:
//!
//! > 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//!
//! How many distinct terms are in the sequence generated by aⁿ for 2 <= a <= 100 and 2 <= n <= 100
//!
//! ## Implementation notes
//!
//! We note that the duplicated entries occur when the base is itself a power. Each base that is
//! not a prime power will add n values to the total. Each base that is a prime power will
//! duplicate example, `2³ = 8`, and so will duplicate all values of the form `8ⁱ = 2³ⁱ` such that
//! `2 <= i <= 100 / 3`.
//!
//! In order to calculate this quickly, first, add n for each base. Now, we go through each base
//! and find which powers are also a base. If the power is `aⁱ`, there will be `100 / i - 1`
//! duplicates. It's one less because 1 is not used as a power.

pub fn run() {
	println!("{}", distinct_powers(100, 100));
}

fn distinct_powers(max_a: u64, max_b: u64) -> u64 {
	let mut n = (max_a - 1) * (max_b - 1);

	for a in 2..=max_a {
		if a * a > max_a {
			break;
		}

		for b in 2..=max_b {
			if a.pow(b as u32) > max_a {
				break;
			}

			n -= max_a / b - 1
		}
	}

	n
}
